<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>智能快递小车</title>
      <link href="/posts/b3b82b56.html"/>
      <url>/posts/b3b82b56.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分：设计概述"><a href="#第一部分：设计概述" class="headerlink" title="第一部分：设计概述"></a>第一部分：设计概述</h1><hr><h2 id="1-1-设计目的"><a href="#1-1-设计目的" class="headerlink" title="1.1 设计目的"></a>1.1 设计目的</h2><p>通过构建智能快递小车原型系统，探索以STM32单片机为行驶主控、以树莓派及其扩展板为辅助的感知、控制和执行完整方案，实现小车在既定道路上自动行驶、摄像头采集与障碍识别、人脸识别与查询取件等功能，为下一步在校园中实际应用奠定基础。在实践过程中，灵活运用各门课程的相关知识，学习和掌握嵌入式软硬件设计的具体方法，加深对控制系统的认识与理解，锤炼复杂工程设计与产品开发全周期、全流程方法、技术和能力。</p><h2 id="1-2-应用领域"><a href="#1-2-应用领域" class="headerlink" title="1.2 应用领域"></a>1.2 应用领域</h2><p>本智能小车系统可以广泛应用于物流、医疗等领域。在医疗领域中，智能小车可以运送医疗器械、标本、医疗废弃品等。智能小车在医疗领域中的应用可以有效解决以下问题：因用于医用物品配送的人力资源过多，导致的人力资源浪费问题；因人为配送不及时，影响诊疗服务质量问题；人为配送出现的送错、损坏、丢失等问题。将本智能小车应用于物流行业，可节约大量的人力资源，从而实现物流领域的降本增效，推动物流产业的转型升级。</p><h2 id="1-3-主要技术特点"><a href="#1-3-主要技术特点" class="headerlink" title="1.3 主要技术特点"></a>1.3 主要技术特点</h2><p>基于STM32MP157DDA1单片机，配合树莓派和其他常用扩展模块电路完成智能小车设计。本作品主要包含以下几个模块：电机驱动模块、循迹模块、机械臂模块、摄像头模块，使用STM32MP157单片机作为主控芯片，实现小车的驱动与循迹；使用树莓派进行图像处理，通过摄像头（平视视觉）识别行人和障碍物等，据此判断小车是否由正常行驶切换到怠速、避障或取件模式，并实现对机械臂的控制：当小车处于取件模式时，机械臂抓取小车上的物件并举起，以便客户取件。主从板之间采用串口通信进行收发指令，树莓派与舵机之间使用I2C串口通信。</p><h2 id="1-4-关键性能指标"><a href="#1-4-关键性能指标" class="headerlink" title="1.4 关键性能指标"></a>1.4 关键性能指标</h2><p> STM32MP157微处理器基于灵活的双Arm Cortex-A7内核（工作频率800 MHz）和Cortex-M4内核（工作频率209 MHz）架构，LFBGA448 封装；核心板板载：1GB DDR3L、8GB EMMC 存储器[1]；可编程串行UART，有多路USB接口，方便与其他板通信；有12个16位可编程定时&#x2F;计数器中断、2个32位定时器和2个16位电机控制定时器；核心板的外部高速晶振(HSE)和外部低速晶振(LSE)分别是：24MHZ和32.768KHZ[2]。</p><h2 id="1-5-主要创新点"><a href="#1-5-主要创新点" class="headerlink" title="1.5 主要创新点"></a>1.5 主要创新点</h2><p>(1)采用STM32主控+树莓派辅助方案，合理分配各开发板SOC的处理能力与板载端口等资源。其中使用STM32MP157控制小车的行驶与巡线；使用树莓派4B基于OpenCV实现对行人和障碍物的识别；通过串口通信向主控板发出统一指令来改变小车的行驶模式；树莓派使用I2C协议控制机械臂的舵机，发送关节参数及静默时间信号以实现机械臂的伸展以及抓取操作。</p><p>(2)建立可反映小车运行时多种情况的状态自动机，用以统一协调来自树莓派摄像头的视觉感知和STM32行驶控制信息。其中机器视觉经Haar分类器得到预测结果，通过不同结果实时判断并发送给主控板控制命令；在每个周期内主控板上状态自动机根据命令进行可能的系统状态切换，更新小车行驶状态。</p><p>(3)小车避障功能的设计与实现。基于对摄像头分别建立的独立采集线程以保证系统实时性，基于状态自动机保证机器视觉与小车本身运行状态的协同，在此基础上设计可对应道路中障碍物的避障模式。避障算法基于多重模板匹配算法，根据摄像头边缘检测结果计算障碍物坐标并引导小车按固定路线（一般是右转-&gt;直行-&gt;左转）避障。</p><hr><h1 id="第二部分-系统组成及功能说明"><a href="#第二部分-系统组成及功能说明" class="headerlink" title="第二部分  系统组成及功能说明"></a>第二部分  系统组成及功能说明</h1><hr><h2 id="2-1整体介绍"><a href="#2-1整体介绍" class="headerlink" title="2.1整体介绍"></a>2.1整体介绍</h2><h3 id="2-1-1-系统整体架构"><a href="#2-1-1-系统整体架构" class="headerlink" title="2.1.1 系统整体架构"></a>2.1.1 系统整体架构</h3><p>单片机STM32MP157DDA1作为主控板，负责控制电机驱动及光电传感器以实现智能小车的自主巡线行驶。树莓派4B作为从控板，负责控制机器视觉模块实现对行人和障碍物的识别，并且通过串口通信向主控板发出控制指令，同时驱动机械臂进行取件动作。</p><p><a href="https://imgloc.com/i/iANiDV"><img src="https://i.328888.xyz/2023/03/25/iANiDV.jpeg" alt="iANiDV.jpeg"></a></p><p>智能小车的总体功能如下：小车能够实现自动依据巡线地图进行行驶；能够依据摄像头识别到的图像自主切换行驶模式，当识别到障碍物时，切换到避障模式，自主躲避障碍物；当识别到行人时，切换到取件模式，小车停止移动，而后控制机械臂拿起物件供客户取件。</p><h3 id="2-1-2-软件系统组成"><a href="#2-1-2-软件系统组成" class="headerlink" title="2.1.2 软件系统组成"></a>2.1.2 软件系统组成</h3><p>图2为智能快递小车的软件系统结构图。</p><p><img src="https://i.328888.xyz/2023/03/25/iANegA.jpeg" alt="iANegA.jpeg"><br>图2 软件系统结构<br>为了实现上述功能要求，设计有控制、通信、机器视觉3个软件子系统。其中控制子系统主要包括小车行驶的速度方向控制、基础巡线控制、小车状态机的转换与PID的控制和对机械臂动作的控制。通信子系统主要包括有线和无线两种，有线方式是指STM32MP157开发板与树莓派4B之间的串口通信，无线方式指通过蓝牙、WiFi等与上位机建立连接用以完成OpenCV在线训练。机器视觉子系统主要包括对于交通标志物的识别和对环境障碍物与人脸的识别，通过对摄像头采集到的图像进行处理、检测等，识别对应的图像。</p><h2 id="2-2各模块介绍"><a href="#2-2各模块介绍" class="headerlink" title="2.2各模块介绍"></a>2.2各模块介绍</h2><p>根据系统总体架构设计，下面给出各模块的具体设计说明。</p><h3 id="2-2-1-小车主控部分"><a href="#2-2-1-小车主控部分" class="headerlink" title="2.2.1 小车主控部分"></a>2.2.1 小车主控部分</h3><p>（1）主要功能<br>小车主控模块主要是实现智能小车的行驶和基础巡线这两个功能。通过PWM实现小车行驶时速度和移动方向的调整；通过PID闭环控制实现小车速度和方向的平滑改变；通过线性CCD模块实现小车的巡线行驶功能。<br>（2）开发板介绍<br><img src="https://i.328888.xyz/2023/03/25/iArEG3.jpeg" alt="iArEG3.jpeg"><br>图3 STM32MP157DDA1开发板</p><p>（3）引脚使用<br><img src="https://i.328888.xyz/2023/03/25/iArGPZ.png" alt="iArGPZ.png"><br>如图3所示，其中TIMX_CHY指的是使用了对应的TIM定时器的CHY通道作为PWM输出&#x2F;输入；GPIO_Mode_Out_PPX指该引脚设置为GPIO的推挽输出模式；JP1、JP2为开发板引出的引脚区域，JP2中的PA5设置为不带上下拉的模拟输入，复用为ADC1通道19。</p><p>图4 STM32MP157引脚使用记录</p><p>主控板子模块——<br>a.电机驱动模块：本项目小车底盘带有4个独立驱动的12V电机，采用2个两路驱动的L298N模块，配合2个5V—&gt;12V的升压模块，实现对电机正反转及转速的控制；使用4路PWM输出来控制电机的转速，通过改变PWM占空比改变速度；小车的转向通过改变一侧2个电机的转动方向，使两侧轮子转向相反来达到转向目的。<br>b.巡线模块：采用TSL1401线性CCD模块，它能采集一行可视像素，TSL1401线性传感器包含了128个线性排列的光电二极管。每个光电二极管都有各自的积分电路,积分电路由相关的电荷放大电路以及一个内部像素数据保持功能组成。内部像素数据保持功能可以为所有像素点提供同时积分的开始和停止时间。该排列由128个像素组成，每个像素的感光面积为3,524.3平方微米。像素之间的间隔为8um。每个像素所采集到的图像灰度值与它所感知的光照强度和积分时间成正比。模块内部控制逻辑简单，只需要串行输入(SI)信号和时钟信号(CLK)[3]；</p><h3 id="2-2-2-树莓派部分"><a href="#2-2-2-树莓派部分" class="headerlink" title="2.2.2 树莓派部分"></a>2.2.2 树莓派部分</h3><p>（1）开发板介绍<br> <img src="https://i.328888.xyz/2023/03/25/iArsyE.png" alt="iArsyE.png"><br>图5 树莓派4B开发板</p><p>（2）引脚使用<br> <img src="https://i.328888.xyz/2023/03/25/iArM7J.png" alt="iArM7J.png"><br>图6 树莓派引脚使用记录<br>如图6所示，复用GPIO14和GPIO15与主板进行串口通讯</p><p>（3）摄像头（机器视觉）<br>连接方式：使用USB连接树莓派开发板。</p><p>小车视觉基于树莓派4B的SOC实现，软件框架基于Python + OpenCV。小车使用双摄像头自主视觉：摄像头1（俯视视觉）完成基本的巡线行驶；摄像头2（平视视觉）负责识别道路旁的行人及障碍物等，识别到之后树莓派板子通过串口通信发消息给stm32板子，stm32（控制板）进行相应的操作。<br>每1ms将摄像头2采集的小车前方图像交由已训练好的Haar分类器进行目标识别，判断是否干预小车正常行驶状态以实现更复杂行驶动作。<br>小车避障功能的设计与实现。基于对摄像头1、2分别建立的独立采集线程以保证系统实时性，基于状态自动机保证双视觉与小车本身运行状态的协同，在此基础上设计可对应道路中障碍物的避障模式。避障算法基于多重模板匹配算法，根据摄像头2边缘检测结果计算障碍物坐标并引导小车按固定路线（一般是右转-&gt;直行-&gt;左转）避障。<br>小车的训练与调试通过WiFi和蓝牙连接上位机与交互设备完成。目前小车已基本实现在所给模拟的学校道路上的自主巡线行驶。对路边的静止障碍（设定是蓝色的物体）的检测和人脸检测等已基本实现。<br>小车的人脸识别基于OpenCV的Haar分类器进行目标识别:<br>Haar分类器算法的要点如下：<br>①　使用Haar-like特征做检测。<br>②　使用积分图（Integral Image）对Haar-like特征求值进行加速。<br>③　使用AdaBoost算法训练区分人脸和非人脸的强分类器。<br>④　使用筛选式级联把强分类器级联到一起，提高准确率。</p><p><img src="https://i.328888.xyz/2023/03/25/iArPPc.png" alt="iArPPc.png"><br>图7 人脸识别流程<br>小车的障碍识别通过提取障碍物的hsv色彩通道实现识别<br>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。<br>这个模型中颜色的参数分别是：色调或者色相（H），饱和度（S），明度（V）</p><p><img src="https://i.328888.xyz/2023/03/25/iArq4V.png" alt="iArq4V.png"><br>图8 HSV模型<br>模型简介：<br>1.H参数表示色彩信息，即所处的光谱颜色的位置。该参数用一角度量来表示，红、绿、蓝分别相隔120度。互补色分别相差180度。<br>2.纯度S为一比例值，范围从0到1，它表示成所选颜色的纯度和该颜色最大的纯度之间的比率。S&#x3D;0时，只有灰度。<br>3.V表示色彩的明亮程度，范围从0到1。有一点要注意：它和光强度之间并没有直接的联系。<br>在对用于目标检测的训练时（这里以蓝色图片标识为例），第一批正样本的采集是我们通过手机对蓝色标识直接进行了拍摄。为了减轻标定部分的工作量，拍摄时特意选取了无过多背景的图片做样本。标定时直接选择整张图片即可，即左上的坐标位（0,0）标定区域的长宽即为图片尺寸24*24。这一轮模型训练中，正样本数设置为1000，负样本数为2763，模型选择为15层。训练时长约90分钟。但是训练结束后将模型嫁接到小车上后发现，手机拍摄的图片清晰度过高，而小车行进时由于加速转弯产生的晃动，使得其内部截获的图片清晰度并不总是很高。正样本的采集方式不当使得，使得小车在循迹时不能很高正确率地识别蓝色图片标识牌（低于50%）。对此，我们重新进行了正样本的采集。第二批正样本书仍为1000，负样本数为2720。此时样本集有大片的背景，我们首先采用了hsv色彩分割原理对蓝色标识进行了标定。重复上述模型建立过程，产生了新的.vec文件和xml文件。最后测试的结果蓝色标识牌的检测正确率有了明显的提升</p><p><img src="https://i.328888.xyz/2023/03/25/iA3HT8.png" alt="iA3HT8.png"><br>图9 人脸识别<br><img src="https://i.328888.xyz/2023/03/25/iA3jpF.png" alt="iA3jpF.png"><br>图10 障碍物识别</p><p>（4）机械臂（执行部件）<br>连接方式：如下图。<br><img src="https://i.328888.xyz/2023/03/25/iA3L5U.png" alt="iA3L5U.png"><br>（a）<br><img src="https://i.328888.xyz/2023/03/25/iARf5E.png" alt="iARf5E.png"><br>(b)<br>图11 (a)连线原理   (b)舵机连线<br>如图11(a)所示，-为负极，+为正极，S为信号线。图11(b)所示为舵机在树莓派上的接口连线位置。<br><img src="https://i.328888.xyz/2023/03/25/iARAOP.jpeg" alt="iARAOP.jpeg"><br>图12 舵机串联<br>如图12所示，本次项目使用机械臂是使用了三个舵机，串联而成。<br>串口总线舵机有如下优势：<br>a.硬件资源占用少——通过单片机控制串行总线舵机，只需要占用两个GPIO管脚（串口的接收端与发送端） 就可以控制最多254个舵机。<br>b.PC可以直接控制舵机——电脑如果想控制传统的PWM舵机的话，中间必须要通过一个单片机，并且要开发PC与单片机的串口通信协议。 对于串口总线舵机来讲，借由转接板，PC可以直接给每个串行总线舵机发送控制指令，对于产品开发或者算法验证就显得非常高效。另外通过PC控制串行总线舵机，只需要占用一个USB口。<br>c.布线简洁美观——串口总线舵机串联的方式，极大的简化了接线的复杂度。<br>d.舵机精度高——串行总线舵机是通过串口通信的方式，将舵机角度按照通信协议写入到字节流数据中，角度传递更可靠且准确。<br>e.数据反馈，舵机保护——串行总线舵机的角度、电压、电流、温度均可以通过串口通信协议发送给单片机&#x2F;PC。通过反馈得到的舵机角度，可以知道舵机是否到达目标角度。在舵机的阻尼模式下，还可以周期性的对舵机角度进行采样，用于机械臂示教。另外当检测到负载过大的时候，可以卸力，不会烧坏舵机。<br>f.内置轨迹规划，平滑流畅——内置轨迹规划算法，操作简单。只需要指定起始位置还有终止位置以及中间的时间间隔，舵机会自动规划轨迹，控制舵机平滑的旋转到目标角度。<br>g.串行总线舵机除了角度模式外，还具有如下模式：<br>轮式控制模式：舵机可以用于小车，舵机支持360度旋转，支持定速与定圈控制；<br>阻尼控制模式：阻尼模式下，对舵机角度周期性轮巡，通过手持机械臂旋转关节的方式，完成示教；<br>智能抓取模式：舵机可以用于机械臂的夹具，根据舵机的电流，智能调整抓取的力度，防止损坏物体。<br>h.支持用户自定义参数设置——串行总线舵机有一个用户自定义参数列表，用户可以根据自己的需求对舵机进行个性化设置。</p><h3 id="2-2-3-通信模块"><a href="#2-2-3-通信模块" class="headerlink" title="2.2.3 通信模块"></a>2.2.3 通信模块</h3><p>(1)小车采集数据使用蓝牙与交互设备通信，用以标注采集的图像。调试时上位机与扩展板通过WiFi通信，训练Haar分类器模型可通过远程窗口直接在小车上进行，也可在上位机端进行。<br>(2)小车的主控板STM32MP157接收的指令遵循图示的通信协议，通过USART串口接收来自PC和树莓派的指令。<br><img src="https://i.328888.xyz/2023/03/25/iARMnA.png" alt="iARMnA.png"><br>帧头：连续收到两个 0x55, 表示有数据包到达；<br>数据长度：等于除帧头两个字节外的待发送的数据的字节数，即 参数个数+2；<br>指令：各种控制指令；<br>参数：除指令外需要补充的控制信息。</p><p>控制小车的指令包括：<br>CMD_CAR_MOVE  &#x3D; 0x01;<br>CMD_CAR_AVOID  &#x3D; 0x02;<br>CMD_CAR_PICKUP &#x3D; 0x03;<br>CMD_CAR_STOP  &#x3D;0x04 ;</p><p>设置波特率为115200；<br><img src="https://i.328888.xyz/2023/03/25/iAcMEy.png" alt="iAcMEy.png"><br>具体接收命令的过程见附录；最后根据接收到的命令执行相应的动作：<br><img src="https://i.328888.xyz/2023/03/25/iAmDWJ.png" alt="iAmDWJ.png"></p><h3 id="2-2-4-供电模块"><a href="#2-2-4-供电模块" class="headerlink" title="2.2.4 供电模块"></a>2.2.4 供电模块</h3><p>小车采用2个18650锂电池组供电。大电池组为6节电芯，具体参数为电压12V，可持续电流3A，容量5000mAh，为STM32MP157开发板进行供电；小电池组为2节电芯，具体参数为电压7.4V，可持续电流4A，容量2200mAh，为树莓派4B进行供电；另有两个5V——12V的升压模块，提供12V电压为两个电机驱动模块供电。此外，树莓派4B共控制摄像头和机械臂这两个模块，且这两个模块不同时工作（取件时小车停止，摄像头关闭，机械臂舵机启动；行驶时摄像头开启，机械臂舵机关闭）。</p><hr><hr><h1 id="第三部分-完成情况及性能参数"><a href="#第三部分-完成情况及性能参数" class="headerlink" title="第三部分  完成情况及性能参数"></a>第三部分  完成情况及性能参数</h1><h2 id="3-1-作品技术路线"><a href="#3-1-作品技术路线" class="headerlink" title="3.1 作品技术路线"></a>3.1 作品技术路线</h2><p>本作品遵循的技术路线如图所示。<br><img src="https://i.328888.xyz/2023/03/25/iAmkNN.jpeg" alt="iAmkNN.jpeg"><br>图13 作品总技术路线框架图</p><p>目前需求分析、硬件选型以及基本的软硬件系统平台搭建已完成。硬件系统主要基于STM32MP157主控和树莓派4B从控实现。软件系统关键部分主要有巡线和PID控制、机械臂控制、主从板之间的通信以及基于OpenCV的机器视觉系统，软件详细设计见3.2节及后续。目前项目整体进入小车控制算法优化环节。小车使用状态自动机在正常行驶、暂停、避障、完全停止4种状态间切换，小车的运行模式包括行驶、取件、避障、停止四种，以模拟快递取件过程中的怠速、紧急避障、熄火停车、取件等功能。</p><h2 id="3-2-软件设计与实现"><a href="#3-2-软件设计与实现" class="headerlink" title="3.2 软件设计与实现"></a>3.2 软件设计与实现</h2><h3 id="3-2-1-软件整体流程"><a href="#3-2-1-软件整体流程" class="headerlink" title="3.2.1 软件整体流程"></a>3.2.1 软件整体流程</h3><p>目前小车主要的软件模块已完成设计与编码。整体流程如图14所示。其中(a)图为主控板（STM32）程序流程，从控板（树莓派4B）程序流程。两板之间使用串口方式通信。<br><a href="https://imgloc.com/i/iAmgk5"><img src="https://i.328888.xyz/2023/03/25/iAmgk5.png" alt="iAmgk5.png"></a><br>(a)主控板软件执行流程</p><p>图14  快递小车软件执行流程</p><h3 id="3-2-2-小车状态机设计"><a href="#3-2-2-小车状态机设计" class="headerlink" title="3.2.2 小车状态机设计"></a>3.2.2 小车状态机设计</h3><p>在图14流程中，我们使用了一个状态自动机用以切换小车的各种运行状态。小车使用状态自动机在正常行驶、暂停、避障、完全停止4种状态间切换，以模拟实际行驶中的路口怠速、识别取件、紧急避障以及熄火停车等功能。图9显示了本作品小车具有的4种状态以及状态间迁移。<br><img src="https://i.328888.xyz/2023/03/25/iAm7JZ.png" alt="iAm7JZ.png"><br>图15 小车状态迁移图<br>可能发生的状态间迁移有：<br>S1  S2：检测到斑马线、STOP标志牌、红灯或者前方有障碍物时<br>S2  S1：障碍物（行人）通过、红灯转绿灯后<br>S1  S3：检测到有静止障碍物（行人）<br>S3  S1：避障或服务动作完成后<br>S2  S3：行人静止不动时（代表有服务需求）<br>S1  S4：进入停车区域<br>S3  S4：进入停车区域<br>小车初始状态（启动时）为S1。每个执行周期内小车均由状态自动机进行可能的状态切换，用以对行驶中各类情况进行控制，并统一发出动作指令。<br>根据流程，每10个延时单位执行一次巡线检测。基于此计算道路中心值，并提供PID控制算法（增量式与位置式）必要的参数进行计算，以修正小车当前的运动方向和速度。进一步地，建立后轮双减速电机差速运动学模型进行控制反馈优化，已体现在不同转弯场景下（路口、紧急避障）控制指令的差异化。<br>目前项目整体进入模型优化以及控制算法优化阶段。</p><h2 id="3-3-具体模块实现"><a href="#3-3-具体模块实现" class="headerlink" title="3.3 具体模块实现"></a>3.3 具体模块实现</h2><h3 id="3-3-1-主控（STM32）"><a href="#3-3-1-主控（STM32）" class="headerlink" title="3.3.1 主控（STM32）"></a>3.3.1 主控（STM32）</h3><p>a.光电传感器：采集一行像素数据，需要分成两步：首先要触发采集，通过改变CCD传感器的CLK引脚和SI引脚来实现触发采集:<br>    TSL_CLK&#x3D;0;<br>    TSL_SI&#x3D;O;&#x2F;&#x2F;CLK和SI均设置为低电平<br>    Dly_us();&#x2F;&#x2F;延时</p><pre><code>TSL_SI=1;//SI电平拉高Dly_us();//延时，使SI的高电平时间维持至少20usDly_us();TSL_CLK=1;//CLK电平拉高Dly_us() ;//延时TSL_SI=0;//SI的下降沿必须在CLK高电平时发生，此时开启数据        采集和AO引脚进行灰度值输出Dly_us();//延时</code></pre><p>接下来进行数据采集：<br>数据采集时是连续采集128个AO引脚的电压信号,因此使用for循环做128次数据的采集，每个电压信号之间通过控制CLK时钟周期做区分。当CLK时钟拉低时开始采集AO引脚的电压，当CLK时钟拉高时结束一次数据的采集。<br>程序中的ADV[]是一个长度为128的数组，用于存放采回的电压值;函数Get_Adc ()作用是读取电压值，括号中的输入变量为对应的采样引脚通道值(与实际使用的STM32引脚有关）;ADC数据采集范围是“0-4096”,“&#x2F;16”后将电压值范围缩小到“0-256”，便于数据处理。采集数据的C语言代码如下所示:<br>for (i&#x3D;0; i&lt;128;i++){<br>    TSL_CLK&#x3D;O;<br>    Dly_us(10);&#x2F;&#x2F;调节曝光时间<br>    ADV[tslp]&#x3D;(Get_Adc(19))&#x2F;16;<br>    ++tslp;<br>    TSL_CLK&#x3D;1 ;<br>    Dly_us();<br>}<br>实际使用过程中，CCD模块的输出电压易受到环境光强和积分时间的影响，为了更好的应用于智能小车的场景，应尽可能降低曝光时间的长度。原因有以下两点:<br>增加积分时间意味着图像采集周期变长，不利于系统的控制。实际情况就是采集周期变长，导致系统控制的反应能力变弱;<br>增加曝光时间还会使图像变模糊，不利于图像处理。这个道理也和相机一样，相机的快门越快,越适合捕捉高速运动的图像，反之则捕捉的图像很模糊。<br>因此，CCD镜头曝光时间的长短应根据赛道的实际光强环境进行设置。在光线较暗的环境中，应该增加曝光时间，以换取亮度合适的图像;在光线较强的环境中，应该减少曝光时间，以防止图像出现饱和现象。本项目的使用环境为室内光照环境，易于协调曝光时间。</p><h3 id="3-3-2-机器视觉（树莓派4B）"><a href="#3-3-2-机器视觉（树莓派4B）" class="headerlink" title="3.3.2 机器视觉（树莓派4B）"></a>3.3.2 机器视觉（树莓派4B）</h3><p>机器视觉训练部分：<br><a href="https://imgloc.com/i/iAmvJc"><img src="https://i.328888.xyz/2023/03/25/iAmvJc.png" alt="iAmvJc.png"></a><br>图16 小车机器视觉流程<br>训练前图像采集部分,我们使用如下基本方法：<br>采集图片数据时首先需要调用videocapture读取摄像头，保存在cap，读取摄像头的代码为：<br>cap&#x3D;cv2.VideoCapture(2)<br>紧接着编写图像获取函数获取摄像头当前所拍摄的图片，再通过线程调用函数，设置线程的休眠时间为0.01秒，这样就可以源源不断的读取摄像头所拍摄的图片了，读取图片的代码为：<br>ret,frame &#x3D; cap.read() #将摄像头拍摄到的画面作为frame的值</p><p>整个训练过程分为以下几步：<br>（下面以蓝色标识牌的识别为例）<br>Step1：创建样本<br>样本分为正、负样本。其中正样本就是我们要检测的目标样本。在这里是蓝色标识牌。负样本就是其他任意的图片。实际模型建立时，负样本选择与正样本相关的图片集为宜。将蓝色标识放置在道路旁的相应位置，利用小车拍摄到的含有蓝色标识的图片作为正样本标定使用的原始数据集。最初，我们借助了opencv的图形标定工具objectMarker，对包含带识别物体的正样本进行采集。但由于1000张正样本手动标定过于费时费力，我们使用hsv色彩提取的方式对无过多干扰（hsv色彩提取的方法受环境光线影响较大，因此实际目标检测时我们没有使用这种方法进行目标检测，但是对于无过多干扰的样本集进行标定是没有问题的）的正样本集内的蓝色区域进行提取，即实现对鲜艳的蓝色的标定。取走蓝色标识牌，在没有目标样本时，利用背景采集负样本。为保证模型的性能，我们采集了1000张正样本，2720张负样本，接近1：3是比较合理的样本比例。<br>Step2：生成正样本描述文件<br>样本描述文件即.vec文件，里面存放二进制数据，是为下一步opencv训练做准备的。正样本需要生成.vec文件，负样本使用.dat文件即可。生成描述文件需要用到opencv自带的opencv_createsamples.exe可执行文件（opencv的安装包里有）。该exe执行时依赖于对应版本部分的dll动态库，需要放在exe文件的相同目录下。然后通过editplus对Step1中产生的标定信息添加上正确的路径，并命名为pos.dat。打开cmd，cd到opencv_createsamples.exe目录下，执行命令opencv_createsamples.exe -info pos.txt -vec pos.vec -num 1000 -w 40 -h 40  创建样本描述文件。运行结束后，done表示创建成功。<br>Step3：训练样本<br>打开cmd，cd到当前目录，运行命令：<br>opencv_traincascade.exe -data TrainCascadeClassification -vec pos.vec -bg neg.txt -numPos 700 -numNeg 2000 -numStages 15 -precalcValBufSize 3000 -precalcIdxBufSize 3000 -featureType LBP -w 40 -h 40<br>训练结束，即可得到一个包含15个训练层的haar分类器模型。<br>Step4：目标识别<br>调用Step3训练出来的分类器文件(.xml文件)对图片中的物体进行识别，该部分常见的操作是框选出目标区域，在这里我们只需要判断图片中是否包含蓝色标识牌，检测到则给返回物体的位置信息得到相对坐标，未检测到则继续检测。</p><h3 id="3-3-3-机械臂（树莓派4B）"><a href="#3-3-3-机械臂（树莓派4B）" class="headerlink" title="3.3.3 机械臂（树莓派4B）"></a>3.3.3 机械臂（树莓派4B）</h3><p>a. 仿真实验与结果：<br>MATLAB仿真结果如下图所示，证明了该运动学算法是有效的，是可以精准控制连续动作的。</p><p><a href="https://imgloc.com/i/iAmazb"><img src="https://i.328888.xyz/2023/03/25/iAmazb.jpeg" alt="iAmazb.jpeg"></a><br><img src="https://i.328888.xyz/2023/03/25/iAmqXw.jpeg" alt="iAmqXw.jpeg"><br>图17 运动学仿真<br>b. 验证算法：<br>机器人轨迹是指机器人在运动过程中的位移、速度、加速度，确定了机器人的轨迹便能确定机器人的运动状态。轨迹规划是根据作业任务的要求，计算出机器人实现预期动作的运动轨迹。机器人的轨迹规划包含点到点运动和连续运动路径运动两种模式，根据参考系坐标的不同，选择不同的轨迹规划。关节空间轨迹规划是采用逆运动学，将初始末端的位姿与结束末端矩阵的位姿转换为转换为初始关节角与结束关节角。然后采用多项式插值方法得到规划的关节角，从而控制机器人进行运动。但在运动过程中，无法对机器人末端位姿进行控制。而笛卡尔空间轨迹规划则是直接对机械臂初始末端位姿到结束末端位姿进行规划，然后利用逆运动学得到当前规划的关节角，从而控制机器人进行运动由于本章是基于智能控制算法和机器人运动学理论用以对机械臂运动过程开展连续控制。所以本章采用笛卡尔空间轨迹规划进行算法验证。<br>使用笛卡尔空间轨迹规划控制机械臂进行运动，计算相对复杂。但能够对机械臂末端的运动轨迹进行控制，从而保证机械臂可以按照预期的方式进行运动，可以使得机械臂各个旋转关节的关节位置、关节角速度以及关节角加速度连续光滑。求解出机械臂末端执行器在工作空间下的位姿随时间变化的函数则是对机械臂的笛卡尔空间轨迹规划。其基本思路是,首先获得笛卡尔空间中的路径序列，采用插补算法使其实现；然对机械臂各个关节的空间坐标进行逆运动学运算,来将机械臂在笛卡尔空间中经过点的位置和姿态映射到机械臂在关节空间中的各关节的位置和姿态。<br>为了实现对六自由度机械臂的连续、精准控制，就要研究笛卡尔空间下的轨迹算法。之后又采用了空间直线插补算法，从而实现机械臂能够按着预期连续路径进行运动。[5]</p><p>c. 端口设置<br>#将串口舵机的指令通过串口发送给舵机（部分，详情见附录）<br>LOBOT_SERVO_FRAME_HEADER         &#x3D; 0x55<br>LOBOT_SERVO_MOVE_TIME_WRITE      &#x3D; 1<br>LOBOT_SERVO_MOVE_TIME_READ       &#x3D; 2<br>LOBOT_SERVO_MOVE_TIME_WAIT_WRITE &#x3D; 7<br>LOBOT_SERVO_MOVE_TIME_WAIT_READ  &#x3D; 8<br>LOBOT_SERVO_MOVE_START           &#x3D; 11<br>LOBOT_SERVO_MOVE_STOP            &#x3D; 12<br>LOBOT_SERVO_ID_WRITE             &#x3D; 13<br>#初始化串口， 波特率为115200</p><p>serialHandle &#x3D; serial.Serial(“&#x2F;dev&#x2F;ttyAMA0”, 115200)<br>#配置RX_CON 即 GPIO17 为输出<br>pi.set_mode(rx_pin, pigpio.OUTPUT)<br>#配置TX_CON 即 GPIO27 为输出<br>pi.set_mode(tx_pin, pigpio.OUTPUT)<br>#配置单线串口为输出&#x2F;输入<br>def portWrite():<br>    pi.write(tx_pin, 1)  # 拉高TX_CON 即 GPIO27<br>    pi.write(rx_pin, 0)  # 拉低RX_CON 即 GPIO17</p><p>def portRead():<br>    pi.write(rx_pin, 1)  # 拉高RX_CON 即 GPIO17<br>    pi.write(tx_pin, 0)  # 拉低TX_CON 即 GPIO27<br>舵机的控制代码<br>#下例中的舵机编号为2号，转动距离为200，用时500ms<br>Board.setBusServoPulse(2, 200, 500)<br>将各个舵机的位置设定好，加以延时，可获得一套完整的动作组<br>驱动串口舵机转到指定位置:<br>param id: 要驱动的舵机id<br>pulse: 位置<br>use_time: 转动需要的时间<br>def setBusServoPulse(id, pulse, use_time):<br>    pulse &#x3D; 0 if pulse &lt; 0 else pulse<br>    pulse &#x3D; 1000 if pulse &gt; 1000 else pulse<br>    use_time &#x3D; 0 if use_time &lt; 0 else use_time<br>    use_time &#x3D; 30000 if use_time &gt; 30000 else use_time<br>    serial_serro_wirte_cmd(id, LOBOT_SERVO_MOVE_TIME_WRITE, pulse, use_time)</p><hr><hr><h1 id="第四部分-总结"><a href="#第四部分-总结" class="headerlink" title="第四部分  总结"></a>第四部分  总结</h1><h2 id="4-1-开发过程体会"><a href="#4-1-开发过程体会" class="headerlink" title="4.1 开发过程体会"></a>4.1 开发过程体会</h2><p>通过本次智能小车系统的设计制作，我们深深地体会到了动手能力与理论知识的重要性，而理论与实践的结合更是重中之重。同时，我们也深感到我们的能力和知识还有很多不足，在设计实现的过程中遇到很多的阻碍和困难，不可避免地遇到一些问题，好在经过老师的帮助和组内成员的共同努力，我们解决了这些问题，实现了系统的设计和调试。</p><h2 id="4-2-待进一步完善功能"><a href="#4-2-待进一步完善功能" class="headerlink" title="4.2 待进一步完善功能"></a>4.2 待进一步完善功能</h2><p>(1)PID控制<br>所谓 PID 控制，就是对系统偏差进行比例、积分以及微分的控制。PID 是闭环 控制，因此需要有传感器测量我们需要控制的参数，并且反馈到我们的控制计算当中，并且参与控制。PID 由 3 个单元组成，分别是比例（Proportion）单元、积分（Integral） 单元、微分（Differential）单元。通过对这三个单元的处理计算输出给执行器，达到 减小偏差最终实现收敛的过程[4]。 </p><p>①　位置式PID<br>位置闭环控制就是根据编码器的脉冲累加测量电机的位置信息，并与目标值进 行比较，得到控制偏差，然后通过对偏差的比例、积分、微分进行控制，使偏差趋向于零的过程。<br>根据位置式离散 PID 公式 ：<br>Pwm&#x3D;Kp<em>e(k)+Ki</em>∑e(k)+Kd[e(k)-e(k-1)]<br>e(k)：本次偏差<br>e(k-1)：上一次的偏差<br>∑e(k)：e(k) 偏差的累积和;其中 k 为 1,2,,k;<br>Pwm：输出<br>Kp：比例项参数<br>Ki：积分项参数<br>Kd：微分项参数<br><a href="https://imgloc.com/i/iAprKJ"><img src="https://i.328888.xyz/2023/03/25/iAprKJ.png" alt="iAprKJ.png"></a><br>图18 位置式PID控制框图<br>如图18所示，图中的目标位置在本项目中可通过从控板的指令实现改变目标值，实时调整目标位置，测量位置则是通过主控板去采集霍尔编码器的数据。目标位置和测量位置之间的差就是目前系统的偏差。送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标位置。 </p><p>②　增量式PID<br>增量式PID即速度闭环控制就是根据单位时间获取的脉冲数（这里使用了 M 法测速）测量电机的速度信息，并与目标值进行比较，得到控制偏差，然后通过对偏差的比例、积分、微分进行控制，使偏差趋向于零的过程。<br>根据增量式离散 PID 公式 ：<br>Pwm+&#x3D;Kp[e(k)-e(k-1)]+Ki<em>e(k)+Kd[e(k)-2e(k-1)+e(k-2)]<br>e(k)：本次偏差<br>e(k-1)：上一次的偏差<br>e(k-2)：上上次的偏差<br>Kp：比例项参数<br>Ki：积分项参数<br>Kd：微分项参数<br>Pwm：代表增量输出<br>在我们的速度控制闭环系统里面只使用 PI 控制，因此对 PID 控制器可简化<br>为以下公式：<br>Pwm+&#x3D;Kp[e(k)-e(k-1)]+Ki</em>e(k)<br><img src="https://i.328888.xyz/2023/03/25/iApBVN.png" alt="iApBVN.png"><br>图19 增量式PID控制框图<br>如图19所示，图中的目标速度一般取小车能安全实现范围内的最大值，可根据小车运动模式的不同而产生对应的改变，如前方出现障碍进入避障模式则减少目标速度的值；测量速度通过主控板定时去采集霍尔编码器的数据并清零。目标速度和测量速度之间的差就是目前系统的偏差。送入 PID 控制器进行计算输出，然后再经过电机驱动的功率放大控制电机的转动去减小偏差，最终达到目标速度。</p><hr><hr><h1 id="第五部分-参考文献"><a href="#第五部分-参考文献" class="headerlink" title="第五部分  参考文献"></a>第五部分  参考文献</h1><p><em>[1] STM32MP157A&amp;D数据手册[EB&#x2F;OL] <a href="http://www.st.com/trademarks">http://www.st.com/trademarks</a></em></p><p><em>[2] STM32MP157参考手册[EB&#x2F;OL] <a href="http://www.st.com/trademarks">http://www.st.com/trademarks</a></em><br><em>[3] CCD原理性教程[EB&#x2F;OL] <a href="http://www.wheeltec.net/">http://www.wheeltec.net</a></em><br><em>[4] PID基础入门：开发手册[EB&#x2F;OL] <a href="http://www.wheeltec.net/">http://www.wheeltec.net</a></em><br><em>[5] 祝东辉. 六自由度机械臂轨迹规划与运动学仿真[D]. 西北师范大学, 2020.</em><br><em>[6] 张平. OpenCV算法精解：基于Python与C++[M].北京：电子工业出版社，2017.</em><br><em>[7] Gary Bradski  Adrian Kaebler. 学习OpenCV[M]. 北京：清华大学出版社</em><br><em>[8] 陈磊.计算机视觉类库OpenCV在VC中的应用[J]. 微计算机信息.2007,23(12): 209-210.</em></p><hr><hr><h1 id="第六部分-附录"><a href="#第六部分-附录" class="headerlink" title="第六部分  附录"></a>第六部分  附录</h1><p>重要代码、推导过程等不便于在正文中体现的内容</p><h2 id="6-1小车主控重要代码"><a href="#6-1小车主控重要代码" class="headerlink" title="6.1小车主控重要代码"></a>6.1小车主控重要代码</h2><p>(1)小车巡线控制<br>void  Get_RC(void)<br>{<br>    static float Bias,Last_Bias;<br>    if(Flag_Way&#x3D;&#x3D;2)<br>    {<br>            RC_Velocity_CCD &#x3D; 350;                          &#x2F;&#x2F;CCD巡线模式线速度<br>            Move_X&#x3D;RC_Velocity_CCD; &#x2F;&#x2F;机器人X轴速度设置<br>            Bias&#x3D;CCD_Median-64;  &#x2F;&#x2F;提取偏差，64为巡线的中心点<br>            Move_Z&#x3D;-Bias<em>CCD_KP</em>0.1f-(Bias-Last_Bias)<em>CCD_KI</em>0.1f; &#x2F;&#x2F;PD控制，原理就是使得小车保持靠近巡线的中心点<br>            Last_Bias&#x3D;Bias;   &#x2F;&#x2F;保存上一次的偏差<br>            if(Move_X&lt;0) Move_Z&#x3D;-Move_Z;<br>                Move_Z&#x3D;Move_Z*RC_Velocity_CCD&#x2F;20100;&#x2F;&#x2F;差速控制原理需要经过此处处理<br>    }<br>            &#x2F;&#x2F;Z-axis data conversion &#x2F;&#x2F;Z轴数据转化<br>            &#x2F;&#x2F;Unit conversion, mm&#x2F;s -&gt; m&#x2F;s<br>            &#x2F;&#x2F;单位转换，mm&#x2F;s -&gt; m&#x2F;s<br>            Move_X&#x3D;Move_X&#x2F;1000;<br>            Move_Z&#x3D;Move_Z;</p><pre><code>        //Control target value is obtained and kinematics analysis is performed        //得到控制目标值，进行运动学分析        Drive_Motor(Move_X,Move_Y,Move_Z);</code></pre><p>}</p><h2 id="6-2机器视觉的关键代码"><a href="#6-2机器视觉的关键代码" class="headerlink" title="6.2机器视觉的关键代码"></a>6.2机器视觉的关键代码</h2><h3 id="1-人脸识别："><a href="#1-人脸识别：" class="headerlink" title="(1)人脸识别："></a>(1)人脸识别：</h3><p>import cv2<br>import time<br>import threading<br>orgFrame &#x3D; None<br>frame    &#x3D; None<br>Running  &#x3D; True<br>ret &#x3D; False<br>cap &#x3D; cv2.VideoCapture(2)<br>def get_image():<br>    global orgFrame<br>    global ret<br>    global Running<br>    global cap<br>    while True:<br>        if Running:<br>            if cap.isOpened():<br>                ret, orgFrame &#x3D; cap.read()<br>            else:<br>                time.sleep(0.001)<br>        else:<br>            time.sleep(0.01)<br>th1 &#x3D; threading.Thread(target&#x3D;get_image)<br>th1.setDaemon(True)<br>th1.start()<br>face_cascade &#x3D; cv2.CascadeClassifier(&amp;apos;haarcascade_frontalface_default.xml&amp;apos;)<br>while True:<br>    if orgFrame is not None and ret :<br>        img&#x3D;orgFrame<br>        gray&#x3D;cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br>        faces&#x3D;face_cascade.detectMultiScale(gray,1.3,5)<br>        if len(faces):<br>            #print(len(faces))<br>            for (x,y,w,h) in faces:<br>                img &#x3D; cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)<br>        cv2.imshow(&amp;apos;1&amp;apos;,img)<br>        cv2.waitKey(1)<br>        #cv2.destroyAllWindows()</p><h3 id="2-障碍识别："><a href="#2-障碍识别：" class="headerlink" title="(2)障碍识别："></a>(2)障碍识别：</h3><p>import cv2<br>import numpy as np #导入库<br>blue_lower &#x3D; np.array([100,43,46])<br>blue_upper &#x3D; np.array([124,255,255]) #设置颜色区间<br>cap &#x3D; cv2.VideoCapture(2)  #打开摄像头<br>cap.set(3,640)<br>cap.set(4,480)  #设置窗口的大小<br>while 1: #进入无线循环<br>    ret,frame &#x3D; cap.read() #将摄像头拍摄到的画面作为frame的值<br>    frame &#x3D; cv2.GaussianBlur(frame,(5,5),0) #高斯滤波GaussianBlur() 让图片模糊<br>    hsv &#x3D; cv2.cvtColor(frame,cv2.COLOR_BGR2HSV) #将图片的色域转换为HSV的样式 以便检测<br>    mask &#x3D; cv2.inRange(hsv,blue_lower,blue_upper)  #设置阈值，去除背景 保留所设置的颜色</p><pre><code>mask = cv2.erode(mask,None,iterations=2) #显示腐蚀后的图像mask = cv2.GaussianBlur(mask,(3,3),0) #高斯模糊res = cv2.bitwise_and(frame,frame,mask=mask) #图像合并cnts = cv2.findContours(mask.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)[-2] #边缘检测if len(cnts) &gt;0 : #通过边缘检测来确定所识别物体的位置信息得到相对坐标    cnt = max(cnts,key=cv2.contourArea)    (x,y),radius = cv2.minEnclosingCircle(cnt)    cv2.circle(frame,(int(x),int(y)),int(radius),(255,0,255),2) #画出一个圆    print(int(x),int(y))else:    passcv2.imshow(&amp;apos;frame&amp;apos;,frame) #将具体的测试效果显示出来huaquan</code></pre><p>   #cv2.imshow(&amp;apos;mask&amp;apos;,mask)<br> #cv2.imshow(&amp;apos;res&amp;apos;,res)<br>    if cv2.waitKey(5) &amp; 0xFF &#x3D;&#x3D; 27: #如果按了ESC就退出<br>        break</p><p>cap.release()<br>cv2.destroyAllWindows() #后面两句是常规操作</p><h2 id="6-3机械臂部分代码"><a href="#6-3机械臂部分代码" class="headerlink" title="6.3机械臂部分代码"></a>6.3机械臂部分代码</h2><p>#实现抓取动作的代码：<br>import time<br>import Board</p><p>while True:<br>    # 参数：参数1：舵机id; 参数2：位置; 参数3：运行时间<br>    Board.setBusServoPulse(2, 500, 500) # 2号舵机转到500位置，用时500ms<br>    time.sleep(0.5) # 延时时间和运行时间相同</p><pre><code>Board.setBusServoPulse(2, 200, 500) #舵机的转动范围0-240度，对应的脉宽为0-1000,即参数2的范围为0-1000time.sleep(0.5)Board.setBusServoPulse(2, 500, 200)time.sleep(0.2)Board.setBusServoPulse(2, 200, 200)time.sleep(0.2)Board.setBusServoPulse(2, 500, 500)  Board.setBusServoPulse(1, 300, 500)time.sleep(0.5)Board.setBusServoPulse(2, 200, 500)  Board.setBusServoPulse(1, 500, 500)time.sleep(0.5)    </code></pre><h2 id="6-4STM32MP157通过串口接收数据的代码"><a href="#6-4STM32MP157通过串口接收数据的代码" class="headerlink" title="6.4STM32MP157通过串口接收数据的代码"></a>6.4STM32MP157通过串口接收数据的代码</h2><p>void USART3_IRQHandler(void)<br>{<br> u8 rxBuf;<br> static uint8 startCodeSum &#x3D; 0;<br> static bool fFrameStart &#x3D; FALSE;<br> static uint8 messageLength &#x3D; 0;<br> static uint8 messageLengthSum &#x3D; 2;<br> if(USART_GetITStatus(USART3, USART_IT_RXNE) !&#x3D; RESET)<br> {<br>  rxBuf &#x3D;USART_ReceiveData(USART3);<br>  if(!fFrameStart)<br>  {<br>   if(rxBuf &#x3D;&#x3D; 0x55)<br>   {<br>    startCodeSum++;<br>    if(startCodeSum &#x3D;&#x3D; 2)<br>    {<br>     startCodeSum &#x3D; 0;<br>     fFrameStart &#x3D; TRUE;<br>     messageLength &#x3D; 1;<br>    }<br>   }<br>   else<br>   {<br>    fFrameStart &#x3D; FALSE;<br>    messageLength &#x3D; 0;<br>    startCodeSum &#x3D; 0;<br>   }<br>  }<br>  if(fFrameStart)<br>  {<br>   UartRxBuffer[messageLength] &#x3D; rxBuf;<br>   if(messageLength &#x3D;&#x3D; 2)<br>   {<br>    messageLengthSum &#x3D; UartRxBuffer[messageLength];<br>    if(messageLengthSum &lt; 2)&#x2F;&#x2F; || messageLengthSum &gt; 30<br>    {<br>     messageLengthSum &#x3D; 2;<br>     fFrameStart &#x3D; FALSE;<br>    }<br>   }<br>   messageLength++;<br>   if(messageLength &#x3D;&#x3D; messageLengthSum + 2)<br>   {<br>    fUartRxComplete &#x3D; TRUE;<br>    fFrameStart &#x3D; FALSE;<br>   }<br>  }<br> }<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能农业大棚</title>
      <link href="/posts/ff6efeb7.html"/>
      <url>/posts/ff6efeb7.html</url>
      
        <content type="html"><![CDATA[<hr><p><em><strong>项目描述：</strong></em><br>设计一个智能农业系统，要求如下：<br>（1）以 TFT 屏作为显示终端，显示大棚温湿度（单位摄氏度、相对湿度）、 光照（单位 lux）信息；显示补光灯、鼓风机（电机模拟）工作状态（开启或关 闭）。其中大棚温湿度来自于温湿度传感器、光照来自于光敏电阻或其他传感器、补 光灯为高亮 LED 输出。<br>（2）温湿度数据、光照数据每隔 2 秒动态刷新；采用合理方式调整温湿度、 光照信号变化，以产生可见动态效果。<br>（3）当大棚温湿度高于某限定值，语音模块报警（报警内容：温湿度超 限），同时鼓风机（电机模拟）工作 5 秒并关闭；当光照低于某限定值，语音模块报 警（报警内容：光照亮度偏低），补光灯亮起，高于某限定值，补光灯灭。<br>（4）当补光灯亮起后，具有自动调节亮度功能，分为三档“弱、中、强”，根 据不同光照强度切换对应档位。<br>（5）设计 4x4 矩阵键盘输入，设置室温、湿、光照限定值报警功能，并实现 声、光报警。<br>（6）设计 RFID 射频 IC 卡功能，可以设置卡的级别：管理卡，用户卡。刷 “管理卡”，屏幕显示管理卡，同时可以制作用户卡；刷“用户卡”，屏幕显示用户 卡。<br>（7）刷“用户卡”，按下功能按键，实现历史数据查询功能，可以记录 30 秒数 据（共 15 次），通过翻页等可实现数据历史查询。</p><hr><hr><p><em><strong>工作原理设想：</strong></em><br>显示：通过TFTLCD屏进行数据以及的显示。<br>补光灯：通过PWM输出来让LED灯充当补光灯，根据不同的光照强度的环境调节LED的发光程度。<br>鼓风机：使用直流电机来模拟鼓风机的运行。<br>温湿度：本设计中的温湿度通过DHT11来获取。<br>光照：光照强度通过光敏电阻获得的不同值来表示。<br>刷新时间2s:通过TIM2通用定时器来定时获取数据输出。<br>报警：不会用语音模块，所以退而求其次用了蜂鸣器。<br>键盘输入：键盘使用矩阵键盘扫描方式来实行中断。<br>RFID卡管理：RC522通过识别不同的卡片ID号来识别不同的卡，主观上认定“管理卡”和“用户卡”并对其识别做出判断和输出。<br>历史数据：历史数据通过flash存储，实现断电可保存数据。<br>翻页：通过LCD的屏幕刷新和按键中断的结合实现翻页。</p><hr><hr><p><strong>main.c展示如下</strong><br>使用板子型号为STM32F103ZET6<br>大部分模块使用杜邦线接在引脚上使用<br>涉及使用RFID技术模拟的权限卡模式，PWM，IIC，USART,EEPROM等<br>主要传感器：<br>温湿度传感器，光敏传感器，TFTLCD，矩阵键盘，蜂鸣器。</p><hr><hr><pre><code>        //main.c        #include &quot;include.h&quot;        #include &quot;stm32f10x.h&quot;        #include &quot;system_stm32f10x.h&quot;        #include &quot;stm32f10x_conf.h&quot;        #include &lt;stdio.h&gt;        #include &quot;MyIIC.h&quot;        #include &quot;delay.h&quot;        #include &quot;flash.h&quot;        #include &quot;exti.h&quot;        #include &quot;tim.h&quot;        #include &quot;lcd.h&quot;        #include &quot;usart.h&quot;        #include &quot;dht11.h&quot;        #include &quot;ULN2003.h&quot;        #include &quot;rc522_function.h&quot;        #include &quot;rc522_config.h&quot;        #include &quot;stdbool.h&quot;        #include &quot;support.h&quot;        #include &quot;string.h&quot;        /*蜂鸣器,鼓风机按键初始化函数声明*/        void ShuChu_Init(void);        /*RFID模块*/        /*        使用卡片ID为：HF31:454764B9                                HF30:751DEDBE                                        可根据自己的卡号ID自己设置管理卡和用户卡        */        uint8_t KeyValue[]=&#123;0xFF ,0xFF, 0xFF, 0xFF, 0xFF, 0xFF&#125;;   // 卡A密钥        uint8_t  pData[16];        char cStr [ 30 ];        uint8_t ucArray_ID [ 4 ];    /*先后存放IC卡的类型和UID(IC卡序列号)*/                                                                                                 uint8_t ucStatusReturn;      /*返回状态*/           /*RFID模块*/        int i,j;        int acess = 0;//判定此刻状态是处于管理卡还是用户卡        u8 page = 0;//页面跳转时的页数        int ALREADY = 0;//判定是否读取了flash的数据        PCF8591T date;//结构体对象        int k=0;        u8 dead_Wendu=29,dead_Shidu=35;        u8 dead_Guangzhao=100;        u16 Guangzhao;        u8 Wendu,Shidu;        float message[45]=&#123;0&#125;; //flash存储数据的中介        int main(void)        &#123;            int x;            SystemInit();/*系统初始化*/        // MotorInit();/*电机初始化*/            uart_init(115200);/*串口初始化*/            LCD_Init();/*LCD初始化*/            RC522_Init ();/*RFID初始化*/            PcdReset ();/*复位RC522*/        M500PcdConfigISOType ( &#39;A&#39; );/*设置工作方式*/                         /*开头显示学校及抽签号*/                        LCD_Set_Window(0,0,220,110);   //该函数后的操作只显示该窗口位置的内容            for(x=150;x&gt;0;x--)            &#123;                LCD_ShowString(30,10+x,220,140,16,&quot;AHNU--16&quot;);//这里以假设抽签号为16为例                delay_ms(10);                LCD_Clear(WHITE);            &#125;            /*开头显示学校及抽签号*/                                    /*主页显示*/            LCD_Set_Window(0,0,200,300);   //该函数后的操作只显示该窗口位置的内容(20,110,200,100)            LCD_Clear(WHITE);            LCD_ShowString(30,50,260,16,24,&quot;Module State&quot;);            POINT_COLOR = RED;            LCD_ShowString(30,110,260,16,16,&quot;dead_Guangzhao:&quot;);            LCD_ShowString(30,130,260,16,16,&quot;MAXTemp:&quot;);             LCD_ShowString(30,150,200,16,16,&quot;MAXHumi:&quot;);            POINT_COLOR = RED;            LCD_ShowString(30,170,260,16,16,&quot;Envir Temp:&quot;);             LCD_ShowString(30,190,200,16,16,&quot;Humi:&quot;);            LCD_ShowString(30,210,200,16,16,&quot;Lux :&quot;);            LCD_ShowString(90+50,170,260,16,16,&quot;C&quot;);             LCD_ShowString(90,190,200,16,16,&quot;%&quot;);            LCD_ShowString(100,210,200,16,16,&quot;lux&quot;);            LCD_ShowString(30+145,110,200,16,16,&quot;lux&quot;);            LCD_ShowString(30+90,130,260,16,16,&quot;C&quot;);            LCD_ShowString(30+90,150,200,16,16,&quot;%&quot;);            EXTI_init();            TIM2_init();/*温湿度传感器,光敏，flash读值*/            TIM3_init();            ShuChu_Init();            while(1)&#123;                                if(date.Guangmin&gt;dead_Guangzhao)&#123;                    Set_Brightness(999);                    if(date.Guangmin&gt;dead_Guangzhao+50) Set_Brightness(600);                    if(date.Guangmin&gt;dead_Guangzhao+100)   Set_Brightness(300);                    else&#123;;&#125;                &#125;                else TIM3-&gt;CCR1=999; //关闭补光灯                                //在LCD屏幕上显示补光灯和鼓风机的工作状态和极限值                if(!ALREADY)                &#123;                    LCD_ShowString(30,230,200,16,16,&quot;buzzer_statue:&quot;);                    LCD_ShowString(30,250,200,16,16,&quot;motor_statue:&quot;);                        POINT_COLOR = BRRED;                    LCD_ShowNum(30+120,110,dead_Guangzhao,3,16);                    LCD_ShowNum(30+70,130,dead_Wendu,2,16);                    LCD_ShowNum(30+70,150,dead_Shidu,2,16);                        POINT_COLOR = RED;                &#125;                //查询补光灯，鼓风机引脚的状态                POINT_COLOR = BLACK;                if(!ALREADY)                &#123;                    if((GPIOB-&gt;ODR&amp;(1&lt;&lt;1))&gt;&gt;1 ==0)                        LCD_ShowString(90+50,230,200,16,16,&quot;open&quot;);                else                                             LCD_ShowString(90+50,230,200,16,16,&quot;close&quot;);                if((GPIOB-&gt;ODR&amp;(1&lt;&lt;2))&gt;&gt;2 == 1)                    LCD_ShowString(90+50,250,200,16,16,&quot;open&quot;);                else                                               LCD_ShowString(90+50,250,200,16,16,&quot;close&quot;);                &#125;                delay_us(10);                        /*RFID*/                /*寻卡*/                if ( ( ucStatusReturn = PcdRequest ( PICC_REQIDL, ucArray_ID ) ) != MI_OK )              /*若失败再次寻卡*/                    ucStatusReturn = PcdRequest ( PICC_REQIDL, ucArray_ID );                                                                if ( ucStatusReturn == MI_OK  )                &#123;            /*防冲撞（当有多张卡进入读写器操作范围时，防冲突机制会从其中选择一张进行操作）*/                    if ( PcdAnticoll ( ucArray_ID ) == MI_OK )                                                                                       &#123;                        PcdSelect(ucArray_ID);                                                PcdAuthState( PICC_AUTHENT1A, 0x11, KeyValue, ucArray_ID );//校验密码                         sprintf ( cStr, &quot;%02X%02X%02X%02X&quot;,ucArray_ID [0], ucArray_ID [1], ucArray_ID [2],ucArray_ID [3] );                        //LCD_ShowString(30,70,220,200,12,(u8 *)cStr);//若不知道自己的卡片的ID为多少，可以在这里用这个函数在TFTLCD上输出ID号，记下后自行设置管理卡和用户卡                        if(!strcmp(cStr,&quot;751DEDBE&quot;))                        &#123;                            acess=0;                            show_chinese(30,280,16,&quot;用户卡\0&quot;,BLACK,WHITE,3);                        &#125;                        else if(!strcmp(cStr,&quot;454764B9&quot;))                        &#123;                            acess=1;                            show_chinese(30,280,16,&quot;管理卡\0&quot;,BLACK,WHITE,3);                        &#125;                                                                    &#125;                    PcdHalt();                &#125;                            /*RFID*/                                            &#125;        &#125;        /*初始化连接到蜂鸣器，鼓风机的按键*/        //使用按键:PB1:蜂鸣器  PB2:电机 推挽输出，10MHz        void ShuChu_Init(void)&#123;            RCC-&gt;APB2ENR|=1ul&lt;&lt;3;            GPIOB-&gt;CRL|=0X00000110;            GPIOB-&gt;CRL&amp;=0XFFFFF11F;            GPIOB-&gt;ODR|=(1UL&lt;&lt;1);            GPIOB-&gt;ODR&amp;=~(1UL&lt;&lt;2);        &#125;        /*每隔两秒采集传感器数据*/        void TIM2_IRQHandler()&#123;            static int i=0;            NVIC-&gt;ICPR[0]|=1ul&lt;&lt;28;            TIM2-&gt;SR&amp;=~(1ul&lt;&lt;0);            i++;            if(i==2)&#123;                i=0;                date=Get_pcf8591();  //采集模拟数据：数据来自于pcf8591t模数转换模块                //采集实际传感器数据                while(DHT11_Read_Data(&amp;Wendu,&amp;Shidu))//读取温湿度值)                &#123;                    DHT11_Read_Data(&amp;Wendu,&amp;Shidu);//读取温湿度值                &#125;                storeto_FLASH(FLASH_SAVE_ADDR,Wendu);                storeto_FLASH(FLASH_SAVE_ADDR,Shidu);                    storeto_FLASH(FLASH_SAVE_ADDR,date.Guangmin);                POINT_COLOR = BLUE;                if(!ALREADY)                &#123;                    LCD_ShowNum(30+90,170,Wendu,2,16);//显示温度                          LCD_ShowNum(30+40,190,Shidu,2,16);//显示湿度                    LCD_ShowNum(30+40,210,date.Guangmin,3,16);//显示光照                &#125;            &#125;        &#125;        void EXTI0_IRQHandler()&#123;            delay_ms(50);            EXTI-&gt;PR|=1UL&lt;&lt;0;            NVIC-&gt;ICPR[0]|=1UL&lt;&lt;6;            GPIOC-&gt;CRL=0x88881111;            GPIOC-&gt;ODR&amp;=~((1ul&lt;&lt;4)|(1ul&lt;&lt;5)|(1ul&lt;&lt;6)|(1ul&lt;&lt;7));            GPIOC-&gt;ODR|=0xffffff0f;            if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;4)))&#123;                //按键S1                dead_Wendu+=1;//温度限定值加一                k++;            &#125;            else if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;5)))&#123;                //S5                dead_Guangzhao+=10;//光照+10            &#125;            else if((GPIOC-&gt;IDR&amp;(1&lt;&lt;6)))&#123;                //S9            &#125;            else if((GPIOC-&gt;IDR&amp;(1&lt;&lt;7)))&#123;                //s13                FLASH_Unlock();                FLASH_ErasePage(FLASH_SAVE_ADDR);                FLASH_Lock();//清空扇区            &#125;            else            &#123;;&#125;            GPIOC-&gt;CRL=0x11118888;              GPIOC-&gt;ODR|=(1ul&lt;&lt;0)|(1ul&lt;&lt;1)|(1ul&lt;&lt;2)|(1ul&lt;&lt;3);            GPIOC-&gt;ODR&amp;=0xffffff0f;            delay_ms(100);        &#125;        void EXTI1_IRQHandler()&#123;            delay_ms(50);            EXTI-&gt;PR|=1UL&lt;&lt;1;            NVIC-&gt;ICPR[0]|=1UL&lt;&lt;7;            GPIOC-&gt;CRL=0x88881111;            GPIOC-&gt;ODR&amp;=~((1ul&lt;&lt;4)|(1ul&lt;&lt;5)|(1ul&lt;&lt;6)|(1ul&lt;&lt;7));            GPIOC-&gt;ODR|=0xffffff0f;            if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;4)))&#123;                //按键S2                dead_Wendu-=1;//温度-1            &#125;            else if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;5)))&#123;                //S6                dead_Guangzhao-=10;//光照-10            &#125;            else if((GPIOC-&gt;IDR&amp;(1&lt;&lt;6)))&#123;                //S10            &#125;            else if(acess==1 &amp;&amp; (GPIOC-&gt;IDR&amp;(1&lt;&lt;7)))&#123;                //s14                page--;                if(page&lt;1)//防误触                &#123;                    page=1;                &#125;                if(ALREADY == 1 &amp;&amp; page == 1)                &#123;                    LCD_Clear(WHITE);                    LCD_ShowString(20,30,260,16,24,&quot;The Historical Data&quot;);                     LCD_ShowString(20,60,260,16,16,&quot;Envir Temp:&quot;);                     LCD_ShowString(70,60,200,16,16,&quot;Humi:&quot;);                    LCD_ShowString(120,60,200,16,16,&quot;Lux :&quot;);                    LCD_ShowString(20,250,200,16,16,&quot;page:&quot;);                    LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[0+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[1+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[2+i*3],3,16);//显示历史光照                    &#125;                &#125;                else if(ALREADY == 1 &amp;&amp; page == 2)                &#123;                    LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[15+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[16+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[17+i*3],3,16);//显示历史光照                    &#125;                &#125;                else if(ALREADY == 1 &amp;&amp; page == 3)                    &#123;                        LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[30+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[31+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[32+i*3],3,16);//显示历史光照                    &#125;                &#125;            &#125;            else            &#123;;&#125;            GPIOC-&gt;CRL=0x11118888;              GPIOC-&gt;ODR|=(1ul&lt;&lt;0)|(1ul&lt;&lt;1)|(1ul&lt;&lt;2)|(1ul&lt;&lt;3);            GPIOC-&gt;ODR&amp;=0xffffff0f;            delay_ms(100);        &#125;        void EXTI2_IRQHandler()&#123;            delay_ms(50);            EXTI-&gt;PR|=1UL&lt;&lt;2;            NVIC-&gt;ICPR[0]|=1UL&lt;&lt;8;            GPIOC-&gt;CRL=0x88881111;            GPIOC-&gt;ODR&amp;=~((1ul&lt;&lt;4)|(1ul&lt;&lt;5)|(1ul&lt;&lt;6)|(1ul&lt;&lt;7));            GPIOC-&gt;ODR|=0xffffff0f;            if(acess==1 &amp;&amp; (GPIOC-&gt;IDR&amp;(1&lt;&lt;4)))&#123;                //按键S3                dead_Shidu+=1; //最大湿度加1            &#125;            else if(GPIOC-&gt;IDR&amp;(1&lt;&lt;5))&#123;                //S7            &#125;            else if(GPIOC-&gt;IDR&amp;(1&lt;&lt;6))&#123;                //S11            &#125;            else if(acess==1 &amp;&amp; (GPIOC-&gt;IDR&amp;(1&lt;&lt;7)))&#123;                //s15                page++;                if(page&gt;3)//防误触                &#123;                    page=3;                &#125;                if(ALREADY == 1 &amp;&amp; page == 1)                &#123;                    LCD_Clear(WHITE);                    LCD_ShowString(20,30,260,16,24,&quot;The Historical Data&quot;);                     LCD_ShowString(20,60,260,16,16,&quot;Envir Temp:&quot;);                     LCD_ShowString(70,60,200,16,16,&quot;Humi:&quot;);                    LCD_ShowString(120,60,200,16,16,&quot;Lux :&quot;);                    LCD_ShowString(20,250,200,16,16,&quot;page:&quot;);                    LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[0+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[1+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[2+i*3],3,16);//显示历史光照                    &#125;                &#125;                else if(ALREADY == 1 &amp;&amp; page == 2)                &#123;                    LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[15+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[16+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[17+i*3],3,16);//显示历史光照                    &#125;                &#125;                else if(ALREADY == 1 &amp;&amp; page == 3)                    &#123;                        LCD_ShowNum(50,250,page,3,16);//显示页数                    for(i=0;i&lt;5;i++)                    &#123;                            LCD_ShowNum(20,80+30*i,message[30+i*3],2,16);//显示历史温度                                LCD_ShowNum(70,80+30*i,message[31+i*3],2,16);//显示历史湿度                            LCD_ShowNum(120,80+30*i,message[32+i*3],3,16);//显示历史光照                    &#125;                &#125;            &#125;            else            &#123;;&#125;            GPIOC-&gt;CRL=0x11118888;              GPIOC-&gt;ODR|=(1ul&lt;&lt;0)|(1ul&lt;&lt;1)|(1ul&lt;&lt;2)|(1ul&lt;&lt;3);            GPIOC-&gt;ODR&amp;=0xffffff0f;            delay_ms(100);        &#125;        void EXTI3_IRQHandler()&#123;            delay_ms(50);            EXTI-&gt;PR|=1UL&lt;&lt;3;            NVIC-&gt;ICPR[0]|=1UL&lt;&lt;9;            GPIOC-&gt;CRL=0x88881111;            GPIOC-&gt;ODR&amp;=~((1ul&lt;&lt;4)|(1ul&lt;&lt;5)|(1ul&lt;&lt;6)|(1ul&lt;&lt;7));            GPIOC-&gt;ODR|=0xffffff0f;            if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;4)))&#123;                //按键S4                dead_Shidu-=1; //最大湿度减1            &#125;            else if(GPIOC-&gt;IDR&amp;(1&lt;&lt;5))&#123;                //S8            &#125;            else if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;6)))&#123;                //S12                ALREADY=0;                LCD_Clear(WHITE);                POINT_COLOR = BLACK;                LCD_ShowString(30,50,260,16,24,&quot;Module State&quot;);                POINT_COLOR = RED;                LCD_ShowString(30,110,260,16,16,&quot;dead_Guangzhao:&quot;);                LCD_ShowString(30,130,260,16,16,&quot;MAXTemp:&quot;);                 LCD_ShowString(30,150,200,16,16,&quot;MAXHumi:&quot;);                POINT_COLOR = BRRED;                LCD_ShowNum(30+120,110,dead_Guangzhao,3,16);                LCD_ShowNum(30+70,130,dead_Wendu,2,16);                LCD_ShowNum(30+70,150,dead_Shidu,2,16);                POINT_COLOR = RED;                LCD_ShowString(30,170,260,16,16,&quot;Envir Temp:&quot;);                 LCD_ShowString(30,190,200,16,16,&quot;Humi:&quot;);                LCD_ShowString(30,210,200,16,16,&quot;Lux :&quot;);                LCD_ShowString(90+50,170,260,16,16,&quot;C&quot;);                 LCD_ShowString(90,190,200,16,16,&quot;%&quot;);                LCD_ShowString(100,210,200,16,16,&quot;lux&quot;);                LCD_ShowString(30+145,110,200,16,16,&quot;lux&quot;);                LCD_ShowString(30+90,130,260,16,16,&quot;C&quot;);                LCD_ShowString(30+90,150,200,16,16,&quot;%&quot;);            &#125;            else if(acess==1 &amp;&amp;(GPIOC-&gt;IDR&amp;(1&lt;&lt;7)))&#123;                //s16                ALREADY = 1;                get_FLASH(FLASH_SAVE_ADDR,message,45);//将传感器数据存放在message中            &#125;            else            &#123;;&#125;            GPIOC-&gt;CRL=0x11118888;              GPIOC-&gt;ODR|=(1ul&lt;&lt;0)|(1ul&lt;&lt;1)|(1ul&lt;&lt;2)|(1ul&lt;&lt;3);            GPIOC-&gt;ODR&amp;=0xffffff0f;            delay_ms(100);        &#125;</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/posts/d87f7e0c.html"/>
      <url>/posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<p>这是一个测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>这是abc</title>
      <link href="/abc.html"/>
      <url>/abc.html</url>
      
        <content type="html"><![CDATA[<p>abc在这里</p>]]></content>
      
    </entry>
    
    
  
</search>
